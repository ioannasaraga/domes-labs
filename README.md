# Lab 8 - Bloom Filters

Σε αυτό το εργαστήριο θα εξετάσουμε την δομή των Bloom Filters. Μια πιθανοτική δομή η οποία μας προσφέρει πολύ γρήγορες αναζητήσεις με το κόστος των false positives.

Η δομή του Bloom Filter, αποτελείται από το struct:
```c
typedef struct bloom_filter {
    unsigned char *array;
    unsigned int size;
} BloomFilter;
```
Στην μεταβλητή size αποθηκεύουμε το μέγεθος του bit array.
Στην μεταβλητή array, έχουμε το ίδιο το bit array. Προσοχή! Μπορεί να δηλώνουμε έναν πίνακα με chars αλλά η διαχείρισή του θα γίνει ως bit array.

## 1. Κατεβάστε τον κώδικα του εργαστηρίου

Στο κώδικα του εργαστηρίου θα βρείτε τα παρακάτω αρχεία:

- [x] `customer/customer.c` : η υλοποίηση μιας δομής customer
- [x] `customer/customer.h` : αναφορές στις συναρτήσεις του customer
- [x] `bloom_filter.c`: το αρχείο με την υλοποίηση του bloom filter
- [x] `bloom_filter.h`: αναφορές στις συναρτήσεις του bloom filter
- [x] `test_bloom_filter.c` : unit tests πάνω στις συναρτήσεις του bloom filter
- [x] `main.c`: main() συνάρτηση για πειραματισμό
- [x] `Makefile`

## 2. Συναρτήσεις που καλείστε να υλοποιήσετε

Στο αρχείο `bloom_filter.c` είναι ήδη υλοποιημένη η συναρτήση `bloom_filter_create` αλλά και ο σκελετός του Bloom Filter. Καλείστε να συμπληρώσετε όλς τις μεθόδους που στο περιεχόμενο τους γράφουν `EXERCISE`. Δηλαδή:

- [ ]  Συνάρτηση που αλλάζει ένα bit σε 1 στην θέση που ορίζει το hash
```c
void bloom_filter_set_bit(BloomFilter *bf,unsigned int hash);
```
- [ ]  Συνάρτηση που ελέγχει αν ένα bit έχει οριστεί ή όχι
```c
unsigned int bloom_filter_get_bit(BloomFilter *bf,unsigned int hash);
```
- [ ]  Συνάρτηση που εισάγει ένα στοιχείο στο bloom filter
```c
void bloom_filter_insert(BloomFilter *bf,Customer *c);
```
- [ ]  Συνάρτηση που ελέγχει αν ένα στοιχείο υπάρχει στο bloom filter
```c
int bloom_filter_check(BloomFilter *bf,Customer *c)
```
- [ ]  Συνάρτηση που αποδεσμέυει τη μνήμη ενός bloom filter
```c
void bloom_filter_destroy(BloomFilter *bf);
```

## 3. Compile & Execution

Ο κώδικας κάνει compile με την εντολή 

```c
make
``` 

ενώ τα tests με την εντολή 

```c
make test
```

Εκτέλεση των tests με 

```c
./test
```

## 4. Παράδοση

Πρέπει να παραδώσετε το εργαστήριο κάνοντας `commit` και `push` στο github repository lab-9-sdiXXXXXXX.

- [ ] `git status `: Ποια είναι η κατάσταση στο git με τις αλλαγές που έχετε κάνει
- [ ] `git add {files changed}`: Προσθέση των αρχείων που έχουν γίνει modified
- [ ] `git status`: Αν έγινε σωστά η προηγούμενη εντολή πρέπει να δείτε το όνομα του αρχείο πράσινο
- [ ] `git commit -m "finished lab-8 exercise"`: Commit στο τοπικό repo
- [ ] `git status`: Check ότι έγινε σωστά το commit
- [ ] `git push`: Ανέβασμα των τοπικών commits στο repote repo
- [ ] `git log`: Θα πρέπει να εμφανιστεί το commit σας στην λίστα με τα log!

---

## Προαιρετικές ασκήσεις 😎

Σας υπενθυμίζουμε ότι οι ασκήσεις αυτές **δεν μετράνε στον βαθμό**. Είναι προαιρετικές και ο μόνος σκοπός ύπαρξης τους είναι να σας δείξουμε κάτι επιπλεόν που μπορεί να βρείτε ενδιαφέρον ή **cool** :^)

### Προαιρετικές ασκήσεις 🏋️

Συμπληρώστε τις (κενές) συναρτήσεις στα αρχεία `swap.c` και `reverse.c` ώστε να υλοποιούν τις εξής λειτουργίες:

- [ ] `swap(int *a, int *b)`: Εναλλάζει τις τιμές των μεταβλητών που δείχνονται από τους δείκτες a και b, μεταξύ τους, αλλά **χωρίς** την χρήση ενδιάμεσης μεταβλητής (συγκεκριμένα, δεν χρειάζεται να ορίσετε καμία καινούργια μεταβλητή). (Hint: bitwise XOR operator)
- [ ] `reverse_byte_order(int num)`: Επιστρέφει την ανεστραμμένη σειρά bytes του δοσμένου integer. Προτείνεται η χρήση δεκαεξαδικών αριθμών για διευκόλυνση. Δοκιμάστε το format `"%.8x"` στην `printf` για την εκτύπωση των δεκαεξαδικών αριθμών. Ενδεικτικά, μια κλήση της με είσοδο τον αριθμό `0x11223344` πρέπει να επιστρέψει τον αριθμό `0x44332211`.

Φτιάξτε και τρέξτε τις `main` των αντίστοιχων αρχείων με τις εντολές `make swap`/`make reverse` και `./swap`/`./reverse` για να επαληθεύσετε τις υλοποιήσεις σας.

### Quiz 1 🗺️

Ακολουθώντας την 2η προαιρετική άσκηση: Εξαρτάται η λειτουργία της συνάρτησης από το endianess (little endian/big endian) του συστήματος που τις τρέχει?
Με άλλα λόγια, είναι το endianess κάτι που κάνει abstract η γλώσσα από τον προγραμματιστή? Ψάξτε το και σκεφτείτε πιθανές εφαρμογές!

### Quiz 2 🧠

Μπορείτε να λύσετε την 2η προαιρετική άσκηση για 32-bit ακρεραίους, υλοποιώντας το ζητούμενο σε ένα μοναδικό macro? Δηλαδή, να έχει την μορφή:

```c
#define reverse_bytes_32(num) ( /*code here*/ )
```
